[ ] Features
  [~] Manually stepping through an execution? -> Can be done by running core
  [ ] Canceling execution
  [ ] Streaming execution to another state machine
  [ ] Upgrading Executions to new State Machine versions
  [ ] Can IO be mocked/replaced without modifying the state machine or execution
  [ ] Idempotency behavior for IO?
[ ] Visualizations to export / support
  [ ] Flow Charts
  [ ] Sequence Diagrams
  [ ] Visualization via State Machine
  [ ] Visualization of an execution
	[ ] Stepping through execution
  [x] GraphViz
  [ ] Xstate
  [ ] Sketch.System
[ ] Testing
  [ ] QuickCheck / Test Check
[ ] Tooling
  [ ] OpenTelemetry
    [ ] Tracing
    [ ] Aggregated Statistics
  [ ] Taps
  [~] Logging -> Using tap> instead
  [~] Execution Funnels

# Nice to haves
[ ] Dev Ergo
  [ ] transitions that specify a state to jump to must exist within the state machine
  [ ] Static Analysis of State Machines
     [ ] Ensure proper error-checking of *output* ?

[ ] Backends
  [ ] Schedulers / Queuing
    [ ] SQS
    [ ] DynamoDB Streaming?
    [ ] GCP Equivalents?
    [ ] Azure Equivalents?
    [ ] HornetQ?
  [ ] Persistence
    [ ] Kafka? (needs research in KTables)
    [ ] DynamoDB
    [ ] Cassandra
    [ ] ElasticSearch?
    [ ] Logging Aggregators?
    [ ] GCP Equivalents?
    [ ] Azure Equivalents?
    [ ] HornetQ?
  [ ] Consider Input handling?
    [ ] Schemas for :state-machine/context and :execution/input
    [ ] Queues
    [ ] HTTP
    [ ] gRPC
[ ] Extensions
  [ ] Custom serialization?
[ ] Explore
  [ ] Cross-Compile
  [ ] ClojureScript / Frontend Web
  [ ] How does this work with UIs?